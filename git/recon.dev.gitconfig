[alias]
  # Utility function. Returns branch name and, if a tracking branch, the tracked branch name & tracking status.
  # Most useful as a helper for `with-tracking`
  branches-with-tracking = "!f() {\
    git for-each-ref \"$@\" --format='%(refname:short) %(upstream:short) %(upstream:track)' refs/heads \
    | awk '{if ($2 != \"\" && $3 == \"\") $3 = \"[synced]\"; print}'; \
  }; f"

  # Select a recent branch by number
  checkout-nth = "!f() {\
    count=$1; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      echo \"Checks out the nth recent branch.\"; \
      echo \"Usage: git checkout-nth [<branch_number=10>]\"; \
      echo \"       git con [<branch_number=10>]\"; \
      return 1; \
    fi; \
    git checkout $(git for-each-ref --count=\"${1:-1}\" --sort=-committerdate refs/heads/ --format='%(refname:short)' | sed -n ${1:-1}p); \
  }; f"

  checkout-nth-remote = "!f() {\
    count=$1; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      echo \"Checks out the nth recent remote branch.\"; \
      echo \"Usage: git checkout-nth-remote [<branch_number=10>]\"; \
      echo \"       git con-r [<branch_number=10>]\"; \
      return 1; \
    fi; \
    localBranches=$(git for-each-ref --format='%(refname:short)' --sort=-committerdate refs/heads/ | tr '\n' '@'); \
    remoteBranch=$(git for-each-ref --count=${count} --sort=-committerdate refs/remotes/ --format='%(refname:short)' | sed -n ${count}p); \
    : 'If remote branch is the 'HEAD' pointer, check out the default branch.'; \
    if [[ $remoteBranch == */HEAD ]]; then \
      : 'Get the name of the remote from remoteBranch'; \
      remote=$(echo $remoteBranch | awk -F/ '{print $1}'); \
      default_branch=$(git print-default-branch $remote); \
      echo \"Checking out default branch '$default_branch'\"; \
      remoteBranch=$remote/$default_branch; \
    fi; \
    : 'If branch exists locally check it out. Otherwise, create a local branch that tracks the remote branch.'; \
    branchWithOption=$(echo $remoteBranch | awk -v localBranches="@"$localBranches -v remoteBranch=$remoteBranch \
      '{ \
        branch = substr($NF, index($NF, \"/\") + 1); \
       if (match(localBranches, \"@\"branch\"@\") != 0) \
          print branch; \
        else \
          print \"--track \" remoteBranch; \
      }'); \
    git checkout ${branchWithOption}; \
  }; f"

  default-branch = "!f() {\
    remote=${1:-origin}; \
    git remote show $remote | grep 'HEAD branch' | awk '{print $NF}'; \
  }; f"

  # TODO: Move to helper aliases
  format-tracking = "!f() { \
    tracking=${1}; \
    echo \"$tracking\" \
    | sed -e 's/\\[ahead \\([0-9]*\\)\\]/\\\\033[32m↑\\1\\\\033[0m/g' \
    | sed -e 's/\\[ahead \\([0-9]*\\), behind \\([0-9]*\\)\\]/\\\\033[32m↑\\1\\\\033[0m\\\\033[31m↓\\2\\\\033[0m/g' \
    | sed -e 's/\\[behind \\([0-9]*\\)\\]/\\\\033[31m↓\\1\\\\033[0m/g' \
    | sed 's/\\[gone\\]/⚠️/g' \
    | sed -e $'s/\\[synced\\]/\\033[32m✔\\033[0m/g'; \
  }; f"

  # TODO: Move to helper aliases
  is-tracking-branch = "!f() {\
    branch=${1:-$(git branch --show-current)}; \
    upstream_branch=$(git for-each-ref --format='%(upstream:short)' refs/heads/${branch}); \
    if [[ -z \"${upstream_branch}\" ]]; then \
      return 1; \
    else \
       return 0; \
    fi; \
  }; f"

  # List recent local branches
  list-recent-branches = "!f() {\
    count=${1:-10}; \
    : 'ref_set: heads | remotes'; \
    ref_set=${2:-heads}; \
    \
    git for-each-ref \
      --color=always \
      --count=${count} \
      refs/${ref_set}/ \
        --sort=-committerdate \
        --format='%(color:blue)%(committerdate:format:%a %Y-%b-%d %H:%M)%(color:reset)|%(color:green)%(authorname)%(color:reset)|%(color:yellow)%(objectname:short)%(color:reset)|%(refname:short)|%(upstream:track)|%(upstream:short)'; \
  }; f"

  # List recent remote branches with formatting
  list-recent-remote-branches = "!f() {\
    count=${1:-10}; \
    ref_set=${2:-heads}; \
    : 'ref_set: heads | remotes'; \
    git for-each-ref \
      --color=always \
      --count=${count} \
      refs/${ref_set}/ \
        --sort=-committerdate \
        --format='%(color:blue)%(committerdate:format:%a %Y-%b-%d %H:%M)%(color:reset)|%(color:green)%(authorname)%(color:reset)|%(color:yellow)%(objectname:short)%(color:reset)|%(refname:short)'; \
  }; f"

  map-remote-branches-to-local-branches = "!f() {\
    git for-each-ref \
      --format='%(refname:short) %(upstream:short)' \
      refs/heads \
  | awk '{\
      if ($2 != \"\") {\
        branch = substr($2, index($2, \"/\") + 1); \
        if (branch == $1) print $2 \" \" $1; \
      } \
    }' \
  | while read -r remote_branch local_branch; do \
      tracking=$(git for-each-ref --format='%(upstream:track)' refs/heads/${local_branch}); \
      if [[ -z "${tracking}" ]]; then \
        tracking='UP_TO_DATE'; \
      elif [[ "${tracking}" == "[gone]" ]]; then \
        tracking=\"\"; \
      fi; \
      tracking=$(git format-tracking \"${tracking}\"); \
      if [[ -n "${tracking}" ]]; then \
        echo \"${remote_branch} ${local_branch} ${tracking}\"; \
      fi; \
    done; \
  }; f"

  recent = "!f() {\
    current_branch=$(git branch --show-current); \
    branches=$(\
      git for-each-ref \
        \"$@\" \
        --format='%(refname:short)' refs/heads/ \
        --sort=-committerdate \
    ); \
    branches_with_tracking=$(\
      git with-tracking \
        --count=10 \
        --color=always \
        --format='%(color:blue)%(committerdate:format:%a %Y-%b-%d %H:%M)%(color:reset)|%(color:green)%(authorname)%(color:reset)|%(color:yellow)%(objectname:short)%(color:reset)|%(refname:short)|%(upstream:short)' \
        \"$@\" \
        --sort=-committerdate \
    ); \
    line_number=1; \
    echo \"$branches_with_tracking\" | while IFS= read -r branch_with_tracking; do \
      branch_name=$(echo \"$branches\" | sed -n \"${line_number}p\"); \
      if [ \"$branch_name\" = \"$current_branch\" ]; then \
        branch_with_line_number=\"▶︎|$branch_with_tracking\"; \
      else \
        branch_with_line_number=\"$line_number|$branch_with_tracking\"; \
      fi; \
      echo \"$branch_with_line_number\" | awk '{\
        if (substr($NF, length($NF)) == \"-\") {\
          print \"  \" substr($0, 1, length($0) - 1); \
        } else {\
          print \"⦿ \" $0; \
        }\
      }'; \
      line_number=$((line_number + 1)); \
    done \
    | column -ts'|'; \
  }; f"

  # List recent local branches with formatting
  recent-branches = "!f() {\
    count=${1:-10}; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      if [[ \"$count\" == \"h\" || \"$count\" == \"help\" ]]; then \
        git show-recent-branches-usage; \
        return 0; \
      fi; \
      echo \"Error: Input is not a numeric string.\"; \
      git show-recent-branches-usage; \
      return 1; \
    fi; \
    current_branch=$(git branch --show-current); \
    output=$(git list-recent-branches $count heads \
    | awk '{print NR \" \" $0}' \
    | awk 'BEGIN{FS=OFS=\"|\"} {if($NF==\"\") $NF=\"\"; else $NF=\"@TRACKING@\"; print}' \
    | awk -v cb=$current_branch '{ \
       split($0, a, \"|\"); \
       remote_branch = a[length(a) - 2]; \
       print (remote_branch == cb ? \"▶︎\" : $1) \"|\" substr($0, length($1) + 2) \
     }' \
    | awk 'BEGIN{FS=OFS=\"|\"} {\
        print (($NF == \"@TRACKING@\" ? \"⦿ \" : \"  \") $0) \
      }' \
    | awk 'BEGIN{FS=OFS=\"|\"} { \
        if($(NF-1)==\"\" && $NF == \"@TRACKING@\") $(NF-1)=\"\\033[32m✔\\033[0m\"; \
        NF--; \
        print \
      }' \
    | rev | sed 's/|/ /' | rev \
    | sed 's/\\[gone\\]/⚠️/g' \
    | column -ts'|'); \
    git format-tracking \"${output}\"; \
  }; f"

  # List recent local branches and prompt to select one to check out
  recent-branches-prompt = "!f() { \
    count=${1:-10}; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      if [[ \"$count\" == \"h\" || \"$count\" == \"help\" ]]; then \
        git show-recent-branches-prompt-usage; \
        return 0; \
      fi; \
      echo \"Error: Input is not a numeric string.\"; \
      git show-recent-branches-prompt-usage; \
      return 1; \
    fi; \
    git recent-branches $count; \
    printf \"Enter branch number to check out branch, [h] for help, or [Enter] to quit: \"; \
    read input; \
    case $input in \
      h) git show-recent-branches-prompt-usage; exit 0 ;; \
      ''|q|0) exit ;; \
      *[!0-9]*) echo 'Error: Input is not a branch number.'; exit 1 ;; \
    esac; \
    git checkout-nth $input; \
  }; f"

  # Run `git recent` and then prompt to check out a branch by number
  recent-prompt = "!f() {\
    git recent \"$@\"; \
    printf \"Enter branch number to check out branch, [h] for help, or [Enter] to quit: \"; \
    read input; \
    case $input in \
      h) git recent-prompt-usage; exit 0 ;; \
      ''|q|0) exit ;; \
      *[!0-9]*) echo 'Error: Input is not a branch number.'; exit 1 ;; \
    esac; \
    git checkout-nth $input; \
  }; f"

  recent-remote = "!f() {\
    current_branch=$(git branch --show-current); \
    : 'Get a list of all local tracking branches, filtering out those whose name is not an exact match'; \
    local_branches_with_tracking=$(\
      git with-tracking \
        --color=always \
        refs/heads/ \
        --format='%(upstream:short) %(refname:short)' \
      | awk '{\
          split($1, remote_segments, \"/\"); \
          remote_branch_name = substr($1, index($1, \"/\") + 1); \
          local_branch_name = $2; \
          if (remote_branch_name == local_branch_name && $3 != \"-\") print $0; \
        }' \
    ); \
    : 'Names of the remote branches, using the same order & filters as the command to run'; \
    : 'We need this because we do not know where in the output the branch name will appear'; \
    remote_branch_names=$(\
      git for-each-ref \
        --count=10 \
        refs/remotes/ \
        \"$@\" \
        --format='%(refname:short)' refs/remotes/ \
        --sort=-committerdate \
    ); \
    : 'The full remote branch information'; \
    remote_branches=$( \
      git for-each-ref \
        --color=always \
        --count=10 \
        refs/remotes/ \
        --format='%(color:blue)%(committerdate:format:%a %Y-%b-%d %H:%M)%(color:reset)|%(color:green)%(authorname)%(color:reset)|%(color:yellow)%(objectname:short)%(color:reset)|%(refname:short)' \
        \"$@\" \
        --sort=-committerdate \
    ); \
    line_number=1; \
    echo \"$remote_branches\" | while IFS= read -r remote_branch; do \
      : 'Get the name of this branch'; \
      remote_branch_name=$(echo \"$remote_branch_names\" | sed -n \"${line_number}p\"); \
      : 'Find the local branch mapped to this branch'; \
      local_branch_with_tracking=$(\
        echo \"$local_branches_with_tracking\" | awk -v name=\"$remote_branch_name\" '$1 == name {print $0}' \
      ); \
      : 'Assume there is no tracking branch'; \
      branch_with_line_number=\"$line_number|$remote_branch\"; \
      if [ -n \"$local_branch_with_tracking\" ]; then \
        local_branch_name=$(echo \"$local_branch_with_tracking\" | awk '{print $2}'); \
        tracking=$(echo \"$local_branch_with_tracking\" | awk '{print $3}'); \
        if [ \"$local_branch_name\" = \"$current_branch\" ]; then \
          branch_with_line_number=\"▶︎|$remote_branch $tracking\"; \
        else \
          branch_with_line_number=\"$line_number|$remote_branch $tracking\"; \
        fi; \
      else \
        if [ \"$remote_branch_name\" = \"HEAD\" ]; then \
          branch_with_line_number=\"$line_number|$remote_branch [@default]\"; \
        fi; \
      fi; \
      slash_count=$(echo \"$remote_branch_name\" | awk -F/ '{print NF-1}'); \
      if [ $slash_count -eq 0 ]; then \
        default_branch_name=$(git default-branch $remote_branch_name); \
        branch_with_line_number=\"$line_number|$remote_branch [default=$default_branch_name]\"; \
      fi; \
      : 'Prepend ⦿ if branch has a tracking branch'; \
      if [ -n \"$local_branch_with_tracking\" ]; then \
        echo \"⦿ $branch_with_line_number\"; \
      else \
        echo \"  $branch_with_line_number\"; \
      fi; \
      line_number=$((line_number + 1)); \
    done \
    | column -ts'|'; \
  }; f"

  recent-remote-branches = "!f() {\
    count=${1:-10}; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      if [[ \"$count\" == \"h\" || \"$count\" == \"help\" ]]; then \
        git show-recent-remote-branches-usage; \
        return 0; \
      fi; \
      echo \"Error: Input is not a numeric string.\"; \
      git show-recent-remote-branches-usage; \
      return 1; \
    fi; \
    branches=$(git for-each-ref --format='%(refname:short)' --sort=-committerdate refs/heads/ | tr '\n' '@'); \
    : 'branch_map=$(git map-remote-branches-to-local-branches)'; \
    current_branch=$(git branch --show-current); \
    : 'Build a hash of remote branches to local branches of the same name'; \
    git list-recent-remote-branches $count remotes \
    | awk \
      -v branches="@"$branches \
      -v branch_map="@"$branch_map \
      -v cb=$current_branch \
      '{ \
        split($0, a, \"|\"); \
        remote_branch = a[length(a)]; \
        branch = substr(remote_branch, index(remote_branch, \"/\") + 1); \
        if (branch == cb) \
          print \"⦿ ▶︎|\" $0; \
        else if (match(branches, \"@\"branch\"@\") != 0) \
          print \"⦿ \" NR \"|\" $0; \
        else if (branch == \"HEAD\") \
          print \"  \" NR \"|\" $0 \" [@default]\"; \
        else \
          print \"  \" NR \"|\" $0; \
      }' \
    | column -ts'|'; \
  }; f"

  # List recent remote branches and prompt to select one to check out
  recent-remote-branches-prompt = "!f() {\
    count=${1:-10}; \
    : 'If count is not a numeric string, print usage and return an error code'; \
    if ! [[ \"$count\" =~ ^[0-9]+$ ]]; then \
      if [[ \"$count\" == \"h\" || \"$count\" == \"help\" ]]; then \
        git show-recent-remote-branches-prompt-usage; \
        return 0; \
      fi; \
      echo \"Error: Input is not a numeric string.\"; \
      git show-recent-remote-branches-prompt-usage; \
      return 1; \
    fi; \
    branches=$(git for-each-ref --format='%(refname:short)' --sort=-committerdate refs/heads/ | tr '\n' '@'); \
    git recent-remote-branches $count; \
    printf \"Enter branch number to check out branch, [h] for help, or [Enter] to quit: \"; \
    read input; \
    case $input in \
      h) git show-recent-remote-branches-prompt-usage; exit 0 ;; \
      ''|q|0) exit ;; \
      *[!0-9]*) echo 'Error: Input is not a branch number.'; exit 1 ;; \
    esac; \
    git checkout-nth-remote $input; \
  }; f"

  recent-legend = "!f() { \
    echo \"LEGEND: ▶︎ current branch\"; \
    echo \"        ⦿ tracking branch | \\033[32m↑ commits ahead\\033[0m | \\033[31m↓ commits behind\\033[0m | \\033[32m✔\\033[0m up to date | ⚠️ upstream gone\"; \
  }; f"

  recent-prompt-usage = "!f() { \
    echo \"Lists recent branches and prompts to check out a branch.\"; \
    echo \"Usage:  git recent-prompt [--count=10]\"; \
    echo \"        git recon [--count=10]\"; \
    git recent-legend; \
  }; f"

  show-recent-branches-usage = "!f() { \
    echo \"Lists recent branches.\"; \
    echo \"Usage:  git recent-branches [<count=10>]\"; \
    echo \"        git recent [<count=10>]\"; \
    git show-recent-branches-legend; \
  }; f"

  show-recent-remote-branches-usage = "!f() { \
      echo \"Lists recent remote branches.\"; \
      echo \"Usage:  git recent-remote-branches [<count=10>]\"; \
      echo \"        git recent-r [<count=10>]\"; \
      git show-recent-remote-branches-legend; \
  }; f"

  show-recent-remote-branches-legend = "!f() { \
    echo \"Legend: ▶︎ current local branch\"; \
    echo \"        ⦿ has local tracking branch\"; \
  }; f"

  show-recent-remote-branches-prompt-usage = "!f() { \
      echo \"Lists recent remote branches and prompts to check out a branch.\"; \
      echo \"Usage:  git recent-remote-branches-prompt [<count=10>]\"; \
      echo \"        git recon-r [<count=10>]\"; \
      git show-recent-remote-branches-legend; \
  }; f"

  # Appends tracking information to each line of the output of the original command
  with-tracking = "!f() {\
    : 'This is a wrapper for for-each-ref refs/heads, so all options will be forwarded to that command.'; \
    : 'But first run the same command and get only tracking information.'; \
    branches_with_tracking=$(\
      git branches-with-tracking refs/heads \"$@\" \
      | while read line; do git format-tracking \"$line\"; done \
      | tr '\n' '@' \
    ); \
    branches=$(\
      git for-each-ref \"$@\" refs/heads/ \
      | tr '\n' '@' \
    ); \
    echo \"$branches\" | awk -F '@' -v bt=\"$branches_with_tracking\" \
      'BEGIN {split(bt, btArr, \"@\"); OFS=\" \"} { \
        for (i = 1; i <= NF; i++) { \
          if ($i == \"\" || btArr[i] == \"\") continue; \
          split(btArr[i], trackingInfo, \" \"); \
          print $i, (length(trackingInfo) >= 3 ? trackingInfo[3] : \"-\"); \
        } \
      }'; \
  }; f"

  # Aliases for "checkout", and combined "list & prompt for checkout": local branches
  con = checkout-nth
  recon = recent-branches-prompt

  # Aliases for "list", "checkout", and combined "list & prompt for checkout": remote branches
  recent-r = recent-remote-branches
  con-r = checkout-nth-remote
  recon-r = recent-remote-branches-prompt
